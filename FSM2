## FSM 2: Vector Transfer Operations-

<b>Aim</b>: To design and implement a digital system whose RTL Program is given

Given RTL Program Steps:-

![image](https://github.com/aryapandit200408/FSMs_in_Verilog/assets/115896451/d356c282-49a5-4180-91ea-6fea8b7ad79e)

<b>Detailed Explanation of the program steps:-</b>
1. If a = 0, b = 0 then control remains in T1
2. If a = 0, b = 1 then control moves to the lat state T4 then again to T1 for a fresh start
3. If a = 1, then the control moves to a new state T2
4. If b = 0, from T2, the control goes to state where another right rotation takes place by one-bit then to state T4
5. If b = 1, from T2, the control goes to state T3 then to T4
5. At state T4 a bus transfer takes place where contents of register R are put on the bus Z and we go back to state T1. Unless loaded, Z shall remain in an unconnected (Z) state

<div align="center">
  
  

An illustration of the FSM
</div>

For this purpose we employ one hot encoding scheme. Let the states be T1, T2, T3, T4 etc

<b>Design:-</b>
We seperate athe design into a Control Unit (FSM) and Logic Unit. The Control Unit (CU) shall control the FSM and the Logic Unit (LU) shall output the value of S = R[0] | R[3] into CU. The CU in-turn shall input the state T into LU.

![image](https://github.com/aryapandit200408/FSMs_in_Verilog/assets/115896451/d1ee09e2-abec-49da-9ca7-4c18cce7b580)


The Control Unit:

Code:-
```
module FSM_OneHot(
    input S,
    input clk,
    input set,
    input rst,
    output [4:1]Zee
    );
    wire [4:1]Zeebar;
    wire W1, W2;
    mux s_mux(Zee[4], Zee[3] , S, W1);
    mux s1_mux(Zee[3], 0, S, W2);
    ms_d_ff M0(W1  , clk, rst, set, Zee[1], Zeebar[1]); //the first ff
    // Note how set and rst are interchanged in order to set state T[1]
    // while other resting 
    ms_d_ff M1(Zee[1], clk, set, rst, Zee[2], Zeebar[2]); //the second ff
    ms_d_ff M2(Zee[2], clk, set, rst, Zee[3], Zeebar[3]); //the third ff
    ms_d_ff M3(W2  , clk, set, rst, Zee[4], Zeebar[4]); //the fourth ff
endmodule
```

The Elaborated Design:-

![image](https://github.com/aryapandit200408/FSMs_in_Verilog/assets/115896451/954394d9-60f5-44a9-93f6-d20a7170bd76)

The Logic Unit:

Code:-
```
`timescale 1ns / 1ps
module top(
    input [3:0]X,
    input [4:1]T,
    input clk,
    input set,
    input rst,
    output S,
    output  [4:1]Zee
    );
    wire [3:0]R;
    wire W2, W3, Sbar;
    register R1(X, clk, T[1], set, rst, R);
    or(W2, R[3],R[0]);
    d_ff s(W2, T[2], set, rst, S, Sbar);
    bufif1 buffer1(Zee[1], R[0], T[4] );
    bufif1 buffer2(Zee[2], R[1], T[4] );
    bufif1 buffer3(Zee[3], R[2], T[4] );
    bufif1 buffer4(Zee[4], R[3], T[4] );   
endmodule
```
The Elaborated Design:-

![image](https://github.com/aryapandit200408/FSMs_in_Verilog/assets/115896451/3c23cacb-762d-4b43-a9b5-ae3b8ba739a0)

The Top Module:- (Connecting CU and LU)

Code:-
```
`timescale 1ns / 1ps

module final(
    input [3:0]X,
    input clk,
    input st,
    input rst,
    output [4:1]Zee,
    inout S,
    inout [4:1]T
    );
    FSM_OneHot ControlUnit(S, clk, st, rst, T[4:1]);
    top LogicUnit(X[3:0], T[4:1], clk, st, rst, S, Zee[4:1]);
endmodule
```

Elaborated Design:-

![image](https://github.com/aryapandit200408/FSMs_in_Verilog/assets/115896451/ce856c24-65fc-458f-8a1a-e36a50d7336c)

<b>Testing for Functional Coveage (Using Behavioral Simulations):-</b>

Testbench Code:-

```
`timescale 1ns / 1ps

module tb_fsm();
    reg [3:0]X;
    reg clk;
    reg set=1;
    reg rst=0;
    wire [4:1]Z;
    wire S;
    wire [4:1]T;
    
    final DUT(X[3:0], clk, set, rst, Z[4:1], S, T[4:1]);
    initial begin
    clk=1'b0;
    forever  begin  
    #10; 
    clk = ~clk;
    end
    end
    
    initial begin
    X <= 4'b0101;   
    #45
    set <= 1;
    rst <= 1;
    #150
    X <= 4'b0000; 
    #150
    X <= 4'b1000;  
    end
endmodule
```

Running Simulations:-

![image](https://github.com/aryapandit200408/FSMs_in_Verilog/assets/115896451/2d9b8e65-fcd8-4538-a0e7-110a58123ae8)

<b>Conclusion:-</b> The design has achieved functional coverage!!!
